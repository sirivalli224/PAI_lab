import heapq

goal = [1,2,3,4,5,6,7,8,0]
moves = {'U':-3,'D':3,'L':-1,'R':1}

def h(b):
    d = 0
    for i,v in enumerate(b):
        if v:
            x1,y1 = i//3, i%3
            x2,y2 = (v-1)//3, (v-1)%3
            d += abs(x1-x2) + abs(y1-y2)
    return d

def neighbors(b):
    z = b.index(0)
    for m,d in moves.items():
        if (m=='U' and z<3) or (m=='D' and z>5) or \
           (m=='L' and z%3==0) or (m=='R' and z%3==2):
            continue
        nb = b[:]
        nz = z + d
        nb[z], nb[nz] = nb[nz], nb[z]
        yield nb, m
def astar(start):
    pq = [(h(start), 0, start, [])]
    visited = set()

    while pq:
        f, g, b, path = heapq.heappop(pq)
        if b == goal:
            return path + [b]
        visited.add(tuple(b))
        for nb, m in neighbors(b):
            if tuple(nb) not in visited:
                heapq.heappush(pq, (g+1+h(nb), g+1, nb, path+[b]))

def show(path):
    for step in path:
        for i in range(0,9,3):
            print(step[i:i+3])
        print()

start = [1,2,3,4,0,5,6,7,8]
solution = astar(start)

if solution:
    print("Solution found:\n")
    show(solution)
else:
    print("No solution")
